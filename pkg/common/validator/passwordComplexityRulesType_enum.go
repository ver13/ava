// code generated by go-enum
// DO NOT EDIT!

package validator

import (
	"fmt"
	"strings"
)

const (
	// PasswordComplexityLowest is a PasswordComplexityRulesType of type PasswordComplexityLowest
	// PasswordComplexityLowest There's no rules besides the minimum length
	PasswordComplexityLowest PasswordComplexityRulesType = iota + 1
	// PasswordComplexityRequireLetter is a PasswordComplexityRulesType of type PasswordComplexityRequireLetter
	// PasswordComplexityRequireLetter At least one letter is required in order to aprove password
	PasswordComplexityRequireLetter
	// PasswordComplexityRequireUpperCase is a PasswordComplexityRulesType of type PasswordComplexityRequireUpperCase
	// PasswordComplexityRequireUpperCase At least one uppercase letter is required in order to aprove password. Only works if PasswordComplexityRequireLetter is included/activated
	PasswordComplexityRequireUpperCase PasswordComplexityRulesType = iota + 2
	// PasswordComplexityRequireNumber is a PasswordComplexityRulesType of type PasswordComplexityRequireNumber
	// PasswordComplexityRequireNumber At least one number is required in order to aprove password
	PasswordComplexityRequireNumber PasswordComplexityRulesType = iota + 5
	// PasswordComplexityRequireSpace is a PasswordComplexityRulesType of type PasswordComplexityRequireSpace
	// PasswordComplexityRequireSpace The password must contain at least one space
	PasswordComplexityRequireSpace PasswordComplexityRulesType = iota + 12
	// PasswordComplexityRequireSymbol is a PasswordComplexityRulesType of type PasswordComplexityRequireSymbol
	// PasswordComplexityRequireSymbol User have to include at least one special character, like # or -
	PasswordComplexityRequireSymbol PasswordComplexityRulesType = iota + 27
)

const _PasswordComplexityRulesTypeName = "PasswordComplexityLowestPasswordComplexityRequireLetterPasswordComplexityRequireUpperCasePasswordComplexityRequireNumberPasswordComplexityRequireSpacePasswordComplexityRequireSymbol"

var _PasswordComplexityRulesTypeMap = map[PasswordComplexityRulesType]string{
	1:  _PasswordComplexityRulesTypeName[0:24],
	2:  _PasswordComplexityRulesTypeName[24:55],
	4:  _PasswordComplexityRulesTypeName[55:89],
	8:  _PasswordComplexityRulesTypeName[89:120],
	16: _PasswordComplexityRulesTypeName[120:150],
	32: _PasswordComplexityRulesTypeName[150:181],
}

// String implements the Stringer interface.
func (x PasswordComplexityRulesType) String() string {
	if str, ok := _PasswordComplexityRulesTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PasswordComplexityRulesType(%d)", x)
}

var _PasswordComplexityRulesTypeValue = map[string]PasswordComplexityRulesType{
	_PasswordComplexityRulesTypeName[0:24]:                     1,
	strings.ToLower(_PasswordComplexityRulesTypeName[0:24]):    1,
	_PasswordComplexityRulesTypeName[24:55]:                    2,
	strings.ToLower(_PasswordComplexityRulesTypeName[24:55]):   2,
	_PasswordComplexityRulesTypeName[55:89]:                    4,
	strings.ToLower(_PasswordComplexityRulesTypeName[55:89]):   4,
	_PasswordComplexityRulesTypeName[89:120]:                   8,
	strings.ToLower(_PasswordComplexityRulesTypeName[89:120]):  8,
	_PasswordComplexityRulesTypeName[120:150]:                  16,
	strings.ToLower(_PasswordComplexityRulesTypeName[120:150]): 16,
	_PasswordComplexityRulesTypeName[150:181]:                  32,
	strings.ToLower(_PasswordComplexityRulesTypeName[150:181]): 32,
}

// ParsePasswordComplexityRulesType attempts to convert a string to a PasswordComplexityRulesType
func ParsePasswordComplexityRulesType(name string) (PasswordComplexityRulesType, error) {
	if x, ok := _PasswordComplexityRulesTypeValue[name]; ok {
		return x, nil
	}
	return PasswordComplexityRulesType(0), fmt.Errorf("%s is not a valid PasswordComplexityRulesType", name)
}

// MarshalText implements the text marshaller method
func (x *PasswordComplexityRulesType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *PasswordComplexityRulesType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePasswordComplexityRulesType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
