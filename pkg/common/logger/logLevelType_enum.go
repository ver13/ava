// Code generated by go-enum
// DO NOT EDIT!

package logger

import (
	"fmt"
	"strings"
	
	errorAVA "github.com/ver13/ava/pkg/common/error"
	errorLoggerAVA "github.com/ver13/ava/pkg/common/logger/error"
)

const (
	// LogLevelTypePanic is a LogLevelType of type Panic
	// Panic level, highest level of severity. Logs and then calls panic with the message passed to debug, info, ...
	LogLevelTypePanic LogLevelType = iota
	// LogLevelTypeFatal is a LogLevelType of type Fatal
	// Fatal level. Logs and then calls `logger.Exit(1)`. It will exit even if the logging level is set to Panic.
	LogLevelTypeFatal
	// LogLevelTypeError is a LogLevelType of type Error
	// Error level. Logs. Used for errors that should definitely be noted.
	LogLevelTypeError
	// LogLevelTypeWarn is a LogLevelType of type Warn
	// Warn level. Non-critical entries that deserve eyes.
	LogLevelTypeWarn
	// LogLevelTypeInfo is a LogLevelType of type Info
	// Info level. General operational entries about what's going on inside the application.
	LogLevelTypeInfo
	// LogLevelTypeDebug is a LogLevelType of type Debug
	// Debug level. Usually only enabled when debugging. Very verbose logging.
	LogLevelTypeDebug
	// LogLevelTypeTrace is a LogLevelType of type Trace
	// Trace level. Designates finer-grained informational events than the debug.
	LogLevelTypeTrace
	// LogLevelTypeUnknown is a LogLevelType of type Unknown
	LogLevelTypeUnknown
)

const _LogLevelTypeName = "PanicFatalErrorWarnInfoDebugTraceUnknown"

var _LogLevelTypeMap = map[LogLevelType]string{
	0: _LogLevelTypeName[0:5],
	1: _LogLevelTypeName[5:10],
	2: _LogLevelTypeName[10:15],
	3: _LogLevelTypeName[15:19],
	4: _LogLevelTypeName[19:23],
	5: _LogLevelTypeName[23:28],
	6: _LogLevelTypeName[28:33],
	7: _LogLevelTypeName[33:40],
}

// String implements the Stringer interface.
func (x LogLevelType) String() string {
	if str, ok := _LogLevelTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("LogLevelType(%d)", x)
}

var _LogLevelTypeValue = map[string]LogLevelType{
	_LogLevelTypeName[0:5]:                    0,
	strings.ToLower(_LogLevelTypeName[0:5]):   0,
	_LogLevelTypeName[5:10]:                   1,
	strings.ToLower(_LogLevelTypeName[5:10]):  1,
	_LogLevelTypeName[10:15]:                  2,
	strings.ToLower(_LogLevelTypeName[10:15]): 2,
	_LogLevelTypeName[15:19]:                  3,
	strings.ToLower(_LogLevelTypeName[15:19]): 3,
	_LogLevelTypeName[19:23]:                  4,
	strings.ToLower(_LogLevelTypeName[19:23]): 4,
	_LogLevelTypeName[23:28]:                  5,
	strings.ToLower(_LogLevelTypeName[23:28]): 5,
	_LogLevelTypeName[28:33]:                  6,
	strings.ToLower(_LogLevelTypeName[28:33]): 6,
	_LogLevelTypeName[33:40]:                  7,
	strings.ToLower(_LogLevelTypeName[33:40]): 7,
}

// ParseLogLevelType attempts to convert a string to a LogLevelType
func ParseLogLevelType(name string) (LogLevelType, *errorAVA.Error) {
	if x, ok := _LogLevelTypeValue[name]; ok {
		return x, nil
	}
	return LogLevelTypeUnknown, errorLoggerAVA.LogLevelUnknown(nil, name)
}

// MarshalText implements the text marshaller method
func (x LogLevelType) MarshalText() ([]byte, *errorAVA.Error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x LogLevelType) UnmarshalText(text []byte) (LogLevelType, *errorAVA.Error) {
	name := string(text)
	tmp, err := ParseLogLevelType(name)
	if err != nil {
		return LogLevelTypeUnknown, err
	}
	x = tmp
	return tmp, nil
}
